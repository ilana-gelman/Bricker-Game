ilana315061945
315061945

1.Package -src:
        in this package there are 2 more packages and the BrickerGameManager:
        1.BrickerGameManager - this class extends from the GameManager(from the danogl)
        It's the game manager - includes the main function, responsible for game initialization
        holding references for game objects, calling update methods for every update iteration.


        2.src.brick_strategies- this package contains all the strategies in case of collision with the brick,
        contains the factory that chooses what strategy to implement and the interface that all the strategy
        classes implement by extending  RemoveBrickStrategyDecorator.
        CollisionStrategy- the interface that all the strategies are implementing.
        BrickStrategyFactory- chooses randomly one ore more strategies to implement in collision.
        (the double strategy is implemented in this factory, because this factory decides what strategies to
        choose and if double strategy was chosen the factory returns the combined strategies)
        RemoveBrickStrategyDecorator - implements the collisionStrategy,
        its decorating the simple removeBrickStrategy by different strategies
        this structure makes the code more organized and clear to understand.
        all the classes in this package  can decorate the simple removeBrickStrategy by extending
        RemoveBrickStrategyDecorator. This  division  make it simple to know each class behavior in case of
        collision and make it easier to control all the classes and make changes if needed.

        the strategies:

        RemoveBrickStrategy-Concrete brick strategy implementing CollisionStrategy interface.
        Removes holding brick on collision.

        AddPaddleStrategy-Concrete class extending abstract RemoveBrickStrategyDecorator.
        Introduces extra paddle to game window which remains until colliding
        NUM_COLLISIONS_FOR_MOCK_PADDLE_DISAPPEARANCE with other game objects.

        ChangeCameraStrategy- Concrete class extending abstract RemoveBrickStrategyDecorator.
        Changes camera focus from ground to ball until ball collides NUM_BALL_COLLISIONS_TO_TURN_OFF times.

        PuckStrategy- Concrete class extending abstract RemoveBrickStrategyDecorator.
        Introduces several pucks instead of brick once removed.

        WidenOrNarrowStrategy-Concrete class extending abstract RemoveBrickStrategyDecorator.
         Introduces buffWiden or
        buffNarrow, that widen or narrow the paddle.

        3.src.gameObjects- this package contains the game objects-
        all the classes in this package overrides the update method and onCollisionEnter method.
        the division to different objects classes makes each object responsibility clear,
        and more objects classes
        can be added without changing nothing in the rest of the classes.

        Ball- is the main game object. It's positioned in game window as part of game initialization and given
        initial velocity. On collision, it's velocity is updated to be reflected about the normal vector of the
        surface it collides with.

        BallCollisionCountdownAgent - An object of this class is instantiated on collision of ball with a brick
        with a change camera strategy.It checks ball's collision counter every frame,
        and once  it finds the ball has collided countDownValue
        times since instantiation, it calls the strategy to reset the camera to normal.

        Brick - the brick object of the game, disappears then the ball/puck collides with it

        BuffWidenOrNarrow- widen or narrow object of the game, widen or narrow the paddle in collision.

        GraphicLifeCounter - Display a graphic object on the game window showing as many widgets as lives left.

        NumericLifeCounter- Display a graphic object on the game window showing a numeric count of lives left.


        Paddle - One of the main game objects. Repels the ball against the bricks.

        MockPaddle -  extend Paddle in collision another paddle is added to the game, and disappears after 3
        collisions with the ball.

        Puck - extends the ball ,One of the types of objects that can be set loose when a brick is hit.

Package -algo_questions:
Solutions - this class contains 4 different   algorithms
alotStudyTime-
1.correctness-
I implemented it as  greedy algorithm:
 In the beginning  , the algorithm sorts the two arrays from  the smallest to largest
it's initializes 2 indexes one for the task array and one for timeslots array.
after that it goes thorough the arrays, if the tasks[i] is smaller or equal to timeslots[j]
it means that the current task can be done in the current timeslot,so we can go forward and advanced i and j
and advance the maximal amount of tasks.
if the tasks[i] greater than timeslots[j], we advance just the j(goes through the timeslot array),
the reason- because the arrays are sorted if the current task didnt match to the timeslot, the next task(witch
is greater than the current) will also not fit to the current time slot, so I advances the j to the next time
slot and i stays as is.
The algorithm continues in this way until the i index reaches to the end of the tasks array or j index reaches
to the end of the timeSlots array.

2. run time-
Sorting the tasks array takes - O(n*log(n))
Sorting the tomeSlots array takes - O(m*log(m))
The algorithms goes  thorough the arrays and stops when it reaches to the end of the smaller array-
O(min(n,m));
each iteration the algorithm does constant number of operations - O(1)
In total the run time is O(n*log(n) + m*log(m) + O(min(n,m)) = O(n*log(n) + m*log(m))


minLeap-

1.correctness-
I implemented it as  greedy algorithm:
In the beginning i initialized 3 variables to zero
numOfJumps -minimal  number of jumps  needed to reach the last leaf
maxReach- the max index we can reach to
curLeaf-the current leaf after we decided to jump
for each index i until leapNum length -1, the algorithm checks if i is greater than the currentLeaf that we
reached to,if true it means that we cannot go forward, and we need to make one more jump
and update the current leaf to be the max reach that we can get to.
Every iteration I check if we can update the maxReach.
The algorithm stores at the curLeaf the previous maxReach,and if
we greater than that(during going over the array) one more jump is needed.
In that way in the end we will get the minimum  requires num of jumps.


2.run time-
the while loop goes until it gets to the input array length - O (n)
each iteration the algorithm does constant number of operations - O(1)
in total - O(n)

bucketWalk-

correctness-
I implemented it as  dynamic algorithm:
In the beginning, I defined the base case, if the trough capacity is 0 or 1 the algorithm will return 1.
I initialize an array that will store the answer in the n'th index
In the i index will be the number of possible sequences to fill i liters
I enter the base cases to the array and with for loop that goes until it gets to n, I enter to the
numOfSequences[i] the sum of the two previous cells,because numOfSequences[i-1] contains the num of different
ways to fill i -1 liters so if we add 1 we will get the ways to fill i liters, and  numOfSequences[i-2]
contains the num of different ways to fill i-2 liters so we can add 2 and get the way to fill i liters.


2.run time-
There are n iterations to fill the array that stores the answer - O(n),
in each iteration the algorithm does constant num of operation(sum and access to specific place in array)-
O(1)
In total the run time is O(n)

numTrees-

correctness-

I implemented it as  dynamic algorithm:
In the beginning, i initialize an array that stores the result in the n'th index
In the i index will be the number of unique BST's with i nodes
after that I enter the base cases to the array (numOfTrees[0] =1)
I used  nested loop, the internal loop goes through the previous elements in the array until i
in each iteration it updates the array[i] by adding the multiplication of array[j]*array[i-j-1],
because,number of BST's in the i'th index is build of left BST's and right BST's
for those trees we already know how many unique trees there are ,according the array
We choose every time different root in the needed range , so for j'th element as the root, j-1 elements can be
on the left and i-j on the right, these sub-trees are itself BST,thus we can add to numOfTrees[i] the
multiplication that i mentioned above.


2.run time-
the first loop runs n times , the second loop runs in the worst case n times,
in each iteration the algorithm does constant num of operation - O(1)
In total -O(n*n)




























